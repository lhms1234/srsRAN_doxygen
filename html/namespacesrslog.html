<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.8.17"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>srsRAN: srslog Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">srsRAN
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.8.17 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#namespaces">Namespaces</a> &#124;
<a href="#nested-classes">Classes</a> &#124;
<a href="#typedef-members">Typedefs</a> &#124;
<a href="#enum-members">Enumerations</a> &#124;
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">srslog Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="namespaces"></a>
Namespaces</h2></td></tr>
<tr class="memitem:namespacesrslog_1_1detail"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog_1_1detail.html">detail</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:namespacesrslog_1_1file__utils"><td class="memItemLeft" align="right" valign="top"> &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog_1_1file__utils.html">file_utils</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="nested-classes"></a>
Classes</h2></td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1backend__worker.html">backend_worker</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrslog_1_1basic__logger__channels.html">basic_logger_channels</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1buffered__file__sink.html">buffered_file_sink</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrslog_1_1context.html">context</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1file__sink.html">file_sink</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1json__formatter.html">json_formatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1log__backend__impl.html">log_backend_impl</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1log__channel.html">log_channel</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrslog_1_1log__channel__config.html">log_channel_config</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Log channel configuration settings.  <a href="structsrslog_1_1log__channel__config.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrslog_1_1metric.html">metric</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrslog_1_1metric__kind__selector.html">metric_kind_selector</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrslog_1_1metric__kind__selector_3_01metric_3_01Ty_00_01Name_00_01Units_01_4_00_01typename2201137cad85797e73eaa824703fccbe.html">metric_kind_selector&lt; metric&lt; Ty, Name, Units &gt;, typename std::enable_if&lt; std::is_arithmetic&lt; Ty &gt;::value &gt;::type &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrslog_1_1metric__list.html">metric_list</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">A generic list to store metric sets of the same type.  <a href="structsrslog_1_1metric__list.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrslog_1_1metric__set.html">metric_set</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrslog_1_1metric__value__formatter.html">metric_value_formatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">The generic metric value formatter.  <a href="structsrslog_1_1metric__value__formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">struct &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="structsrslog_1_1metric__value__formatter_3_01metric_3_01Ty_00_01Name_00_01Units_01_4_01_4.html">metric_value_formatter&lt; metric&lt; Ty, Name, Units &gt; &gt;</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1object__repository.html">object_repository</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1sink.html">sink</a></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1srslog__instance.html">srslog_instance</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Singleton of the framework containing all the required classes.  <a href="classsrslog_1_1srslog__instance.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1stream__sink.html">stream_sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sink implementation writes to either stdout or stderr streams.  <a href="classsrslog_1_1stream__sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1syslog__sink.html">syslog_sink</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">This sink implementation writes to syslog.  <a href="classsrslog_1_1syslog__sink.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:"><td class="memItemLeft" align="right" valign="top">class &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="classsrslog_1_1text__formatter.html">text_formatter</a></td></tr>
<tr class="memdesc:"><td class="mdescLeft">&#160;</td><td class="mdescRight">Plain text formatter implementation class.  <a href="classsrslog_1_1text__formatter.html#details">More...</a><br /></td></tr>
<tr class="separator:"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="typedef-members"></a>
Typedefs</h2></td></tr>
<tr class="memitem:a7756cbe0fe0d67feb9ae24228235f253"><td class="memTemplParams" colspan="2">template&lt;typename... Ts&gt; </td></tr>
<tr class="memitem:a7756cbe0fe0d67feb9ae24228235f253"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a7756cbe0fe0d67feb9ae24228235f253">build_context_type</a> = <a class="el" href="structsrslog_1_1context.html">context</a>&lt; typename std::decay&lt; Ts &gt;::type... &gt;</td></tr>
<tr class="separator:a7756cbe0fe0d67feb9ae24228235f253"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a544e29a66f96eb150fb15dbcf2fe2ced"><td class="memTemplParams" colspan="2">template&lt;typename T , typename Enum &gt; </td></tr>
<tr class="memitem:a544e29a66f96eb150fb15dbcf2fe2ced"><td class="memTemplItemLeft" align="right" valign="top">using&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a544e29a66f96eb150fb15dbcf2fe2ced">build_logger_type</a> = <a class="el" href="classsrslog_1_1detail_1_1logger__impl.html">detail::logger_impl</a>&lt; T, Enum &gt;</td></tr>
<tr class="separator:a544e29a66f96eb150fb15dbcf2fe2ced"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a89b5529471f90d5a87a25d5fb327f817"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a89b5529471f90d5a87a25d5fb327f817">basic_logger</a> = <a class="el" href="namespacesrslog.html#a544e29a66f96eb150fb15dbcf2fe2ced">build_logger_type</a>&lt; <a class="el" href="structsrslog_1_1basic__logger__channels.html">basic_logger_channels</a>, <a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84">basic_levels</a> &gt;</td></tr>
<tr class="separator:a89b5529471f90d5a87a25d5fb327f817"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aeef1a25fb1b5027288884a431890e33e"><td class="memItemLeft" align="right" valign="top">using&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#aeef1a25fb1b5027288884a431890e33e">error_handler</a> = std::function&lt; void(const std::string &amp;)&gt;</td></tr>
<tr class="memdesc:aeef1a25fb1b5027288884a431890e33e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Generic error handler callback.  <a href="namespacesrslog.html#aeef1a25fb1b5027288884a431890e33e">More...</a><br /></td></tr>
<tr class="separator:aeef1a25fb1b5027288884a431890e33e"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="enum-members"></a>
Enumerations</h2></td></tr>
<tr class="memitem:afef9c6375d509fc210a53b8429f0f0ce"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#afef9c6375d509fc210a53b8429f0f0ce">metric_kind</a> { <a class="el" href="namespacesrslog.html#afef9c6375d509fc210a53b8429f0f0cea49057168d24dc9566533ec48326ced2c">metric_kind::numeric</a>, 
<a class="el" href="namespacesrslog.html#afef9c6375d509fc210a53b8429f0f0ceab45cffe084dd3d20d928bee85e7b0f21">metric_kind::string</a>
 }</td></tr>
<tr class="memdesc:afef9c6375d509fc210a53b8429f0f0ce"><td class="mdescLeft">&#160;</td><td class="mdescRight">Metric formatting kinds for textual conversion.  <a href="namespacesrslog.html#afef9c6375d509fc210a53b8429f0f0ce">More...</a><br /></td></tr>
<tr class="separator:afef9c6375d509fc210a53b8429f0f0ce"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2f24235d23f40dcc7be241dd20d53e84"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84">basic_levels</a> { <br />
&#160;&#160;<a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84a334c4a4c42fdb79d7ebc3e73b517e6f8">basic_levels::none</a>, 
<a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84acb5e100e5a9a3e7f6d1fd97512215282">basic_levels::error</a>, 
<a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84a7b83d3f08fa392b79e3f553b585971cd">basic_levels::warning</a>, 
<a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84acaf9b6b99962bf5c2264824231d7a40c">basic_levels::info</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84aad42f6697b035b7580e4fef93be20b4d">basic_levels::debug</a>, 
<a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84af447f5c03508de4d88e340390ba7c78f">basic_levels::LAST</a>
<br />
 }</td></tr>
<tr class="memdesc:a2f24235d23f40dcc7be241dd20d53e84"><td class="mdescLeft">&#160;</td><td class="mdescRight">Basic logger with four levels.  <a href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84">More...</a><br /></td></tr>
<tr class="separator:a2f24235d23f40dcc7be241dd20d53e84"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:abaa7a7501dbd413398b3d6f951f58773"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#abaa7a7501dbd413398b3d6f951f58773">backend_priority</a> { <a class="el" href="namespacesrslog.html#abaa7a7501dbd413398b3d6f951f58773afea087517c26fadd409bd4b9dc642555">backend_priority::normal</a>, 
<a class="el" href="namespacesrslog.html#abaa7a7501dbd413398b3d6f951f58773a8d966b2253a917086c8604959e152243">backend_priority::high</a>, 
<a class="el" href="namespacesrslog.html#abaa7a7501dbd413398b3d6f951f58773aaa4cea18ae7516f9a3c28d597055082f">backend_priority::very_high</a>
 }</td></tr>
<tr class="memdesc:abaa7a7501dbd413398b3d6f951f58773"><td class="mdescLeft">&#160;</td><td class="mdescRight">Backend priority levels.  <a href="namespacesrslog.html#abaa7a7501dbd413398b3d6f951f58773">More...</a><br /></td></tr>
<tr class="separator:abaa7a7501dbd413398b3d6f951f58773"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac63a825d4f47c99e518bee30c3567bb2"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2">syslog_local_type</a> { <br />
&#160;&#160;<a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2a5383337459a9ea598578681bcb0480db">syslog_local_type::local0</a>, 
<a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2a0b38c3f207fab673809810d9e049414c">syslog_local_type::local1</a>, 
<a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2a35e9bee79b773c9023fe5f1df96624f0">syslog_local_type::local2</a>, 
<a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2ae1bc28e8f1beac9d97588c9447c48353">syslog_local_type::local3</a>, 
<br />
&#160;&#160;<a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2a9bd88603540bcee76ec0374a17bd6730">syslog_local_type::local4</a>, 
<a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2a1274d108a43d042dccf76d44de99e186">syslog_local_type::local5</a>, 
<a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2a51ba87b7504c20a3ebbce00aacf4b5e1">syslog_local_type::local6</a>, 
<a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2a1830d14f102923840362ae13e7f7f937">syslog_local_type::local7</a>
<br />
 }</td></tr>
<tr class="memdesc:ac63a825d4f47c99e518bee30c3567bb2"><td class="mdescLeft">&#160;</td><td class="mdescRight">syslog log local types  <a href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2">More...</a><br /></td></tr>
<tr class="separator:ac63a825d4f47c99e518bee30c3567bb2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ace9d9fc68d9ff222dc0768295504c7e1"><td class="memItemLeft" align="right" valign="top">enum &#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#ace9d9fc68d9ff222dc0768295504c7e1">sink_stream_type</a> { <a class="el" href="namespacesrslog.html#ace9d9fc68d9ff222dc0768295504c7e1a64322f5f3ff7f9f717279e1b017a997e">sink_stream_type::stdout</a>, 
<a class="el" href="namespacesrslog.html#ace9d9fc68d9ff222dc0768295504c7e1a41be535153c4b535bc9d0a610d3bd66b">sink_stream_type::stderr</a>
 }</td></tr>
<tr class="memdesc:ace9d9fc68d9ff222dc0768295504c7e1"><td class="mdescLeft">&#160;</td><td class="mdescRight">Standard stream types.  <a href="namespacesrslog.html#ace9d9fc68d9ff222dc0768295504c7e1">More...</a><br /></td></tr>
<tr class="separator:ace9d9fc68d9ff222dc0768295504c7e1"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table><table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:a946c60f818b3d826b1f5a0f0ba376150"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a946c60f818b3d826b1f5a0f0ba376150">event_trace_init</a> ()</td></tr>
<tr class="separator:a946c60f818b3d826b1f5a0f0ba376150"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0dd303fae83828d4ee378345cec28035"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a0dd303fae83828d4ee378345cec28035">event_trace_init</a> (<a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> &amp;<a class="el" href="viterbi37__port_8c.html#a121f7b27b4294ca915809456722511d4">c</a>)</td></tr>
<tr class="separator:a0dd303fae83828d4ee378345cec28035"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a67cfe514d89a22663b1e341f0587f6d8"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a67cfe514d89a22663b1e341f0587f6d8">event_trace_init</a> (const std::string &amp;filename, std::size_t capacity=1024 *1024)</td></tr>
<tr class="separator:a67cfe514d89a22663b1e341f0587f6d8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0921e1312e0de12d19f1cc898958d9dd"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84">basic_levels</a>&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a0921e1312e0de12d19f1cc898958d9dd">str_to_basic_level</a> (std::string s)</td></tr>
<tr class="memdesc:a0921e1312e0de12d19f1cc898958d9dd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a string to the corresponding logger basic level.  <a href="namespacesrslog.html#a0921e1312e0de12d19f1cc898958d9dd">More...</a><br /></td></tr>
<tr class="separator:a0921e1312e0de12d19f1cc898958d9dd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ada7ef73c4b346e5eb9876cfc5d1d563a"><td class="memItemLeft" align="right" valign="top">const char *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#ada7ef73c4b346e5eb9876cfc5d1d563a">basic_level_to_string</a> (<a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84">basic_levels</a> level)</td></tr>
<tr class="memdesc:ada7ef73c4b346e5eb9876cfc5d1d563a"><td class="mdescLeft">&#160;</td><td class="mdescRight">Translates a logger basic level to the corresponding string.  <a href="namespacesrslog.html#ada7ef73c4b346e5eb9876cfc5d1d563a">More...</a><br /></td></tr>
<tr class="separator:ada7ef73c4b346e5eb9876cfc5d1d563a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a92ad8357c6a61d0342715fdedd2b17d2"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a92ad8357c6a61d0342715fdedd2b17d2">find_log_channel</a> (const std::string &amp;id)</td></tr>
<tr class="separator:a92ad8357c6a61d0342715fdedd2b17d2"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a72d4a47f68245076fdac9f070fc540c0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a72d4a47f68245076fdac9f070fc540c0">fetch_log_channel</a> (const std::string &amp;id)</td></tr>
<tr class="separator:a72d4a47f68245076fdac9f070fc540c0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7ac88c2d34ede7e8394cb57051cd5460"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a7ac88c2d34ede7e8394cb57051cd5460">fetch_log_channel</a> (const std::string &amp;id, <a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;s, <a class="el" href="structsrslog_1_1log__channel__config.html">log_channel_config</a> config)</td></tr>
<tr class="separator:a7ac88c2d34ede7e8394cb57051cd5460"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1c83f08fb622ebdf2565d1d7e472779f"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a1c83f08fb622ebdf2565d1d7e472779f">create_log_channel</a> (const std::string &amp;id, <a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;s)</td></tr>
<tr class="separator:a1c83f08fb622ebdf2565d1d7e472779f"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a09c20c3b17519c97a8d2ba157b1d3540"><td class="memTemplParams" colspan="2">template&lt;typename T &gt; </td></tr>
<tr class="memitem:a09c20c3b17519c97a8d2ba157b1d3540"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a09c20c3b17519c97a8d2ba157b1d3540">find_logger</a> (const std::string &amp;id)</td></tr>
<tr class="separator:a09c20c3b17519c97a8d2ba157b1d3540"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7c6cd017ea70905a8cb4486b7a7fdda6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesrslog.html#a89b5529471f90d5a87a25d5fb327f817">basic_logger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a7c6cd017ea70905a8cb4486b7a7fdda6">fetch_basic_logger</a> (const std::string &amp;id, bool should_print_context=true)</td></tr>
<tr class="separator:a7c6cd017ea70905a8cb4486b7a7fdda6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aca914c2ce2b461b62dfb2723df730913"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesrslog.html#a89b5529471f90d5a87a25d5fb327f817">basic_logger</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#aca914c2ce2b461b62dfb2723df730913">fetch_basic_logger</a> (const std::string &amp;id, <a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;s, bool should_print_context=true)</td></tr>
<tr class="separator:aca914c2ce2b461b62dfb2723df730913"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a22630d99c74c1fd5d1574212b5749851"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:a22630d99c74c1fd5d1574212b5749851"><td class="memTemplItemLeft" align="right" valign="top">T &amp;&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a22630d99c74c1fd5d1574212b5749851">fetch_logger</a> (const std::string &amp;id, Args &amp;&amp;... args)</td></tr>
<tr class="separator:a22630d99c74c1fd5d1574212b5749851"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad179db9a6fea451e2989677341b35900"><td class="memItemLeft" align="right" valign="top"><a class="el" href="namespacesrslog.html#a89b5529471f90d5a87a25d5fb327f817">basic_logger</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#ad179db9a6fea451e2989677341b35900">create_basic_logger</a> (const std::string &amp;id, <a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;s, bool should_print_context=true)</td></tr>
<tr class="separator:ad179db9a6fea451e2989677341b35900"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:addbe61eeebecd284aedecc7a9be9eaa1"><td class="memTemplParams" colspan="2">template&lt;typename T , typename... Args&gt; </td></tr>
<tr class="memitem:addbe61eeebecd284aedecc7a9be9eaa1"><td class="memTemplItemLeft" align="right" valign="top">T *&#160;</td><td class="memTemplItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#addbe61eeebecd284aedecc7a9be9eaa1">create_logger</a> (const std::string &amp;id, Args &amp;&amp;... args)</td></tr>
<tr class="separator:addbe61eeebecd284aedecc7a9be9eaa1"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aefdd9a58c2b2885ec468ae3abd80cfa7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#aefdd9a58c2b2885ec468ae3abd80cfa7">set_default_log_formatter</a> (std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt; <a class="el" href="vector__test_8c.html#a3efb0e1a16208deecbd84c15401f7cf8">f</a>)</td></tr>
<tr class="separator:aefdd9a58c2b2885ec468ae3abd80cfa7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad5a7547e404f0bc584bd6a70da6cb657"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#ad5a7547e404f0bc584bd6a70da6cb657">get_default_log_formatter</a> ()</td></tr>
<tr class="memdesc:ad5a7547e404f0bc584bd6a70da6cb657"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instance of the default formatter being used.  <a href="namespacesrslog.html#ad5a7547e404f0bc584bd6a70da6cb657">More...</a><br /></td></tr>
<tr class="separator:ad5a7547e404f0bc584bd6a70da6cb657"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a40c6d308d4a5050c458b0a3b23ec0e2d"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a40c6d308d4a5050c458b0a3b23ec0e2d">create_text_formatter</a> ()</td></tr>
<tr class="memdesc:a40c6d308d4a5050c458b0a3b23ec0e2d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of a plain text formatter.  <a href="namespacesrslog.html#a40c6d308d4a5050c458b0a3b23ec0e2d">More...</a><br /></td></tr>
<tr class="separator:a40c6d308d4a5050c458b0a3b23ec0e2d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a810127ddf1d2fcb2a11742f94122c436"><td class="memItemLeft" align="right" valign="top">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a810127ddf1d2fcb2a11742f94122c436">create_json_formatter</a> ()</td></tr>
<tr class="memdesc:a810127ddf1d2fcb2a11742f94122c436"><td class="mdescLeft">&#160;</td><td class="mdescRight">Creates a new instance of a JSON formatter.  <a href="namespacesrslog.html#a810127ddf1d2fcb2a11742f94122c436">More...</a><br /></td></tr>
<tr class="separator:a810127ddf1d2fcb2a11742f94122c436"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1d3a09079d5f4719cfa542e7bb17efed"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a1d3a09079d5f4719cfa542e7bb17efed">set_default_sink</a> (<a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;s)</td></tr>
<tr class="separator:a1d3a09079d5f4719cfa542e7bb17efed"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a0623fc7d81853101ea2ba91af52cacd6"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a0623fc7d81853101ea2ba91af52cacd6">get_default_sink</a> ()</td></tr>
<tr class="memdesc:a0623fc7d81853101ea2ba91af52cacd6"><td class="mdescLeft">&#160;</td><td class="mdescRight">Returns the instance of the default sink being used.  <a href="namespacesrslog.html#a0623fc7d81853101ea2ba91af52cacd6">More...</a><br /></td></tr>
<tr class="separator:a0623fc7d81853101ea2ba91af52cacd6"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a749ff4d70c896d2116b8e37dbcc5f1a4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1sink.html">sink</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a749ff4d70c896d2116b8e37dbcc5f1a4">find_sink</a> (const std::string &amp;id)</td></tr>
<tr class="separator:a749ff4d70c896d2116b8e37dbcc5f1a4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7bb4851a82eba1da59777a916b577435"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a7bb4851a82eba1da59777a916b577435">fetch_stdout_sink</a> (const std::string &amp;id=&quot;stdout&quot;, std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt; <a class="el" href="vector__test_8c.html#a3efb0e1a16208deecbd84c15401f7cf8">f</a>=<a class="el" href="namespacesrslog.html#ad5a7547e404f0bc584bd6a70da6cb657">get_default_log_formatter</a>())</td></tr>
<tr class="separator:a7bb4851a82eba1da59777a916b577435"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a621fabd5f188dfb4507fb7f95cbd4c95"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a621fabd5f188dfb4507fb7f95cbd4c95">fetch_stderr_sink</a> (const std::string &amp;id=&quot;stderr&quot;, std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt; <a class="el" href="vector__test_8c.html#a3efb0e1a16208deecbd84c15401f7cf8">f</a>=<a class="el" href="namespacesrslog.html#ad5a7547e404f0bc584bd6a70da6cb657">get_default_log_formatter</a>())</td></tr>
<tr class="separator:a621fabd5f188dfb4507fb7f95cbd4c95"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a32cd2feb425304352c404a0bb3820bd0"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a32cd2feb425304352c404a0bb3820bd0">fetch_file_sink</a> (const std::string &amp;path, size_t max_size=0, bool force_flush=false, std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt; <a class="el" href="vector__test_8c.html#a3efb0e1a16208deecbd84c15401f7cf8">f</a>=<a class="el" href="namespacesrslog.html#ad5a7547e404f0bc584bd6a70da6cb657">get_default_log_formatter</a>())</td></tr>
<tr class="separator:a32cd2feb425304352c404a0bb3820bd0"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a7eb515b75d44f0e4605e51f3f9e489e9"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a7eb515b75d44f0e4605e51f3f9e489e9">fetch_syslog_sink</a> (const std::string &amp;preamble_=&quot;&quot;, <a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2">syslog_local_type</a> log_local_=<a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2a5383337459a9ea598578681bcb0480db">syslog_local_type::local0</a>, std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt; <a class="el" href="vector__test_8c.html#a3efb0e1a16208deecbd84c15401f7cf8">f</a>=<a class="el" href="namespacesrslog.html#ad5a7547e404f0bc584bd6a70da6cb657">get_default_log_formatter</a>())</td></tr>
<tr class="separator:a7eb515b75d44f0e4605e51f3f9e489e9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a052d09ff6ba29cfbb6c7fa4ab55fba98"><td class="memItemLeft" align="right" valign="top">bool&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a052d09ff6ba29cfbb6c7fa4ab55fba98">install_custom_sink</a> (const std::string &amp;id, std::unique_ptr&lt; <a class="el" href="classsrslog_1_1sink.html">sink</a> &gt; s)</td></tr>
<tr class="separator:a052d09ff6ba29cfbb6c7fa4ab55fba98"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad760e2151e622885672d4dfc8d48def4"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1sink.html">sink</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#ad760e2151e622885672d4dfc8d48def4">create_file_sink</a> (const std::string &amp;path, size_t max_size=0)</td></tr>
<tr class="separator:ad760e2151e622885672d4dfc8d48def4"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a03e25eac8a5194da24a61c1d822784a8"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1sink.html">sink</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a03e25eac8a5194da24a61c1d822784a8">create_stdout_sink</a> (const std::string &amp;name=&quot;stdout&quot;)</td></tr>
<tr class="separator:a03e25eac8a5194da24a61c1d822784a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a1993dfa16168200c10f5c7a663b76c23"><td class="memItemLeft" align="right" valign="top"><a class="el" href="classsrslog_1_1sink.html">sink</a> *&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a1993dfa16168200c10f5c7a663b76c23">create_stderr_sink</a> (const std::string &amp;name=&quot;stderr&quot;)</td></tr>
<tr class="separator:a1993dfa16168200c10f5c7a663b76c23"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6a7c7c3e1d4bdf3c1ebe9a69378c6a6a"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a6a7c7c3e1d4bdf3c1ebe9a69378c6a6a">init</a> (<a class="el" href="namespacesrslog.html#abaa7a7501dbd413398b3d6f951f58773">backend_priority</a> priority=<a class="el" href="namespacesrslog.html#abaa7a7501dbd413398b3d6f951f58773afea087517c26fadd409bd4b9dc642555">backend_priority::normal</a>)</td></tr>
<tr class="separator:a6a7c7c3e1d4bdf3c1ebe9a69378c6a6a"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a87b0feff706ec57dfdeb274d43d72863"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a87b0feff706ec57dfdeb274d43d72863">flush</a> ()</td></tr>
<tr class="separator:a87b0feff706ec57dfdeb274d43d72863"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:af10e6d28e5102d0a6a8156a6ac39c823"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#af10e6d28e5102d0a6a8156a6ac39c823">set_error_handler</a> (<a class="el" href="namespacesrslog.html#aeef1a25fb1b5027288884a431890e33e">error_handler</a> handler)</td></tr>
<tr class="separator:af10e6d28e5102d0a6a8156a6ac39c823"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2806d7ab3f3c1eaf24ad0706d376df35"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#a2806d7ab3f3c1eaf24ad0706d376df35">trace_duration_begin</a> (const std::string &amp;category, const std::string &amp;name)</td></tr>
<tr class="separator:a2806d7ab3f3c1eaf24ad0706d376df35"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aac8f98c047129b542615897470087126"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespacesrslog.html#aac8f98c047129b542615897470087126">trace_duration_end</a> (const std::string &amp;category, const std::string &amp;name)</td></tr>
<tr class="separator:aac8f98c047129b542615897470087126"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Copyright 2013-2022 Software Radio Systems Limited</p>
<p>This file is part of srsRAN.</p>
<p>srsRAN is free software: you can redistribute it and/or modify it under the terms of the GNU Affero General Public License as published by the Free Software Foundation, either version 3 of the License, or (at your option) any later version.</p>
<p>srsRAN is distributed in the hope that it will be useful, but WITHOUT ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or FITNESS FOR A PARTICULAR PURPOSE. See the GNU Affero General Public License for more details.</p>
<p>A copy of the GNU Affero General Public License can be found in the LICENSE file in the top-level directory of this distribution and at <a href="http://www.gnu.org/licenses/">http://www.gnu.org/licenses/</a>. </p>
</div><h2 class="groupheader">Typedef Documentation</h2>
<a id="a89b5529471f90d5a87a25d5fb327f817"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a89b5529471f90d5a87a25d5fb327f817">&#9670;&nbsp;</a></span>basic_logger</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesrslog.html#a89b5529471f90d5a87a25d5fb327f817">srslog::basic_logger</a> = typedef <a class="el" href="namespacesrslog.html#a544e29a66f96eb150fb15dbcf2fe2ced">build_logger_type</a>&lt;<a class="el" href="structsrslog_1_1basic__logger__channels.html">basic_logger_channels</a>, <a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84">basic_levels</a>&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="a7756cbe0fe0d67feb9ae24228235f253"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7756cbe0fe0d67feb9ae24228235f253">&#9670;&nbsp;</a></span>build_context_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename... Ts&gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesrslog.html#a7756cbe0fe0d67feb9ae24228235f253">srslog::build_context_type</a> = typedef <a class="el" href="structsrslog_1_1context.html">context</a>&lt;typename std::decay&lt;Ts&gt;::type...&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Builds a context type using a list of metric set types. eg: using my_context_t = <a class="el" href="namespacesrslog.html#a7756cbe0fe0d67feb9ae24228235f253">srslog::build_context_type&lt;set1_t, set2_t&gt;</a>; NOTE: Adding duplicated types into the list is not allowed. </p>

</div>
</div>
<a id="a544e29a66f96eb150fb15dbcf2fe2ced"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a544e29a66f96eb150fb15dbcf2fe2ced">&#9670;&nbsp;</a></span>build_logger_type</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename Enum &gt; </div>
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesrslog.html#a544e29a66f96eb150fb15dbcf2fe2ced">srslog::build_logger_type</a> = typedef <a class="el" href="classsrslog_1_1detail_1_1logger__impl.html">detail::logger_impl</a>&lt;T, Enum&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The build_logger_type type alias allows developers to define new logger types in an application.</p>
<p>To create a new logger type simply follow these steps: 1) Define an enum class where each element will represent a logging level. Order the elements from highest to lowest logging level. First element should be "none", which represents a disabled logger. The last element should be called LAST as it is a sentinel value. 2) Define a struct composed by only <a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> references. Declare the members in the same order as done in the enum. 3) Define the new logger type by using the build_logger_type alias. Pass the previous defined types as template parameters.</p>
<p>Example to declare a logger with three logging levels: error, warning and info, being error the highest logging level and info the lowest: 1) Define the logging level enum: enum class three_level_logger_levels { none, error, warning, info, LAST }; 2) Define the struct of three channels (same order as in the enum): struct three_level_logger { <a class="el" href="classsrslog_1_1log__channel.html">log_channel</a>  <a class="el" href="classsrslog_1_1log__channel.html">log_channel</a>  <a class="el" href="classsrslog_1_1log__channel.html">log_channel</a>  }; 3) Define the new logger type: using my_new_logger = build_logger_type&lt;three_level_logger, three_level_logger_levels&gt;; </p>

</div>
</div>
<a id="aeef1a25fb1b5027288884a431890e33e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aeef1a25fb1b5027288884a431890e33e">&#9670;&nbsp;</a></span>error_handler</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">using <a class="el" href="namespacesrslog.html#aeef1a25fb1b5027288884a431890e33e">srslog::error_handler</a> = typedef std::function&lt;void(const std::string&amp;)&gt;</td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Generic error handler callback. </p>

</div>
</div>
<h2 class="groupheader">Enumeration Type Documentation</h2>
<a id="abaa7a7501dbd413398b3d6f951f58773"></a>
<h2 class="memtitle"><span class="permalink"><a href="#abaa7a7501dbd413398b3d6f951f58773">&#9670;&nbsp;</a></span>backend_priority</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesrslog.html#abaa7a7501dbd413398b3d6f951f58773">srslog::backend_priority</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Backend priority levels. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="abaa7a7501dbd413398b3d6f951f58773afea087517c26fadd409bd4b9dc642555"></a>normal&#160;</td><td class="fielddoc"><p>Default priority of the operating system. </p>
</td></tr>
<tr><td class="fieldname"><a id="abaa7a7501dbd413398b3d6f951f58773a8d966b2253a917086c8604959e152243"></a>high&#160;</td><td class="fielddoc"><p>Thread will be given a high priority. </p>
</td></tr>
<tr><td class="fieldname"><a id="abaa7a7501dbd413398b3d6f951f58773aaa4cea18ae7516f9a3c28d597055082f"></a>very_high&#160;</td><td class="fielddoc"><p>Thread will be given a very high priority. </p>
</td></tr>
</table>

</div>
</div>
<a id="a2f24235d23f40dcc7be241dd20d53e84"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2f24235d23f40dcc7be241dd20d53e84">&#9670;&nbsp;</a></span>basic_levels</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84">srslog::basic_levels</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Basic logger with four levels. </p>
<p>Common logger types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="a2f24235d23f40dcc7be241dd20d53e84a334c4a4c42fdb79d7ebc3e73b517e6f8"></a>none&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2f24235d23f40dcc7be241dd20d53e84acb5e100e5a9a3e7f6d1fd97512215282"></a>error&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2f24235d23f40dcc7be241dd20d53e84a7b83d3f08fa392b79e3f553b585971cd"></a>warning&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2f24235d23f40dcc7be241dd20d53e84acaf9b6b99962bf5c2264824231d7a40c"></a>info&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2f24235d23f40dcc7be241dd20d53e84aad42f6697b035b7580e4fef93be20b4d"></a>debug&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="a2f24235d23f40dcc7be241dd20d53e84af447f5c03508de4d88e340390ba7c78f"></a>LAST&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="afef9c6375d509fc210a53b8429f0f0ce"></a>
<h2 class="memtitle"><span class="permalink"><a href="#afef9c6375d509fc210a53b8429f0f0ce">&#9670;&nbsp;</a></span>metric_kind</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesrslog.html#afef9c6375d509fc210a53b8429f0f0ce">srslog::metric_kind</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Metric formatting kinds for textual conversion. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="afef9c6375d509fc210a53b8429f0f0cea49057168d24dc9566533ec48326ced2c"></a>numeric&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="afef9c6375d509fc210a53b8429f0f0ceab45cffe084dd3d20d928bee85e7b0f21"></a>string&#160;</td><td class="fielddoc"><p>Metric represents a numeric value. </p>
<p>Metric represents a string. </p>
</td></tr>
</table>

</div>
</div>
<a id="ace9d9fc68d9ff222dc0768295504c7e1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ace9d9fc68d9ff222dc0768295504c7e1">&#9670;&nbsp;</a></span>sink_stream_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesrslog.html#ace9d9fc68d9ff222dc0768295504c7e1">srslog::sink_stream_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Standard stream types. </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ace9d9fc68d9ff222dc0768295504c7e1a64322f5f3ff7f9f717279e1b017a997e"></a>stdout&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ace9d9fc68d9ff222dc0768295504c7e1a41be535153c4b535bc9d0a610d3bd66b"></a>stderr&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<a id="ac63a825d4f47c99e518bee30c3567bb2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac63a825d4f47c99e518bee30c3567bb2">&#9670;&nbsp;</a></span>syslog_local_type</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">enum <a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2">srslog::syslog_local_type</a></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">strong</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>syslog log local types </p>
<table class="fieldtable">
<tr><th colspan="2">Enumerator</th></tr><tr><td class="fieldname"><a id="ac63a825d4f47c99e518bee30c3567bb2a5383337459a9ea598578681bcb0480db"></a>local0&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac63a825d4f47c99e518bee30c3567bb2a0b38c3f207fab673809810d9e049414c"></a>local1&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac63a825d4f47c99e518bee30c3567bb2a35e9bee79b773c9023fe5f1df96624f0"></a>local2&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac63a825d4f47c99e518bee30c3567bb2ae1bc28e8f1beac9d97588c9447c48353"></a>local3&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac63a825d4f47c99e518bee30c3567bb2a9bd88603540bcee76ec0374a17bd6730"></a>local4&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac63a825d4f47c99e518bee30c3567bb2a1274d108a43d042dccf76d44de99e186"></a>local5&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac63a825d4f47c99e518bee30c3567bb2a51ba87b7504c20a3ebbce00aacf4b5e1"></a>local6&#160;</td><td class="fielddoc"></td></tr>
<tr><td class="fieldname"><a id="ac63a825d4f47c99e518bee30c3567bb2a1830d14f102923840362ae13e7f7f937"></a>local7&#160;</td><td class="fielddoc"></td></tr>
</table>

</div>
</div>
<h2 class="groupheader">Function Documentation</h2>
<a id="ada7ef73c4b346e5eb9876cfc5d1d563a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ada7ef73c4b346e5eb9876cfc5d1d563a">&#9670;&nbsp;</a></span>basic_level_to_string()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">const char* srslog::basic_level_to_string </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84">basic_levels</a>&#160;</td>
          <td class="paramname"><em>level</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a logger basic level to the corresponding string. </p>

</div>
</div>
<a id="ad179db9a6fea451e2989677341b35900"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad179db9a6fea451e2989677341b35900">&#9670;&nbsp;</a></span>create_basic_logger()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesrslog.html#a89b5529471f90d5a87a25d5fb327f817">basic_logger</a> * srslog::create_basic_logger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_print_context</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new basic logger instance (see basic_logger type) with the specified id string and sink, registering it into the logger repository so that it can be later retrieved in other parts of the application. The context value of the logger can be printed on each log entry by setting to true the should_print_context argument. All logger channels will write into the specified sink. Returns a pointer to the newly created logger, otherwise when a logger is already registered with the same id it returns nullptr. NOTE: Deprecated, use fetch_basic_logger instead. </p>

</div>
</div>
<a id="ad760e2151e622885672d4dfc8d48def4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad760e2151e622885672d4dfc8d48def4">&#9670;&nbsp;</a></span>create_file_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1sink.html">sink</a> * srslog::create_file_sink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em> = <code>0</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new sink that writes into the a file in the specified path and registers it into a sink repository so that it can be later retrieved in other parts of the application. Returns a pointer to the newly created sink or nullptr if a sink with the same path was already registered. Specifying a max_size value different to zero will make the sink create a new file each time the current file exceeds this value. The units of max_size are bytes. NOTE: Deprecated, use fetch_file_sink instead. </p>

</div>
</div>
<a id="a810127ddf1d2fcb2a11742f94122c436"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a810127ddf1d2fcb2a11742f94122c436">&#9670;&nbsp;</a></span>create_json_formatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt; srslog::create_json_formatter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of a JSON formatter. </p>

</div>
</div>
<a id="a1c83f08fb622ebdf2565d1d7e472779f"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1c83f08fb622ebdf2565d1d7e472779f">&#9670;&nbsp;</a></span>create_log_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> * srslog::create_log_channel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new log channel instance with the specified id string and sink, then registers it in the log channel repository so that it can be later retrieved in other parts of the application. Returns a pointer to the newly created channel, otherwise when a channel is already registered with the same id it returns nullptr. NOTE: The input id string should not contain any '#' characters otherwise nullptr is returned. NOTE: Deprecated, use fetch_log_channel instead. </p>

</div>
</div>
<a id="addbe61eeebecd284aedecc7a9be9eaa1"></a>
<h2 class="memtitle"><span class="permalink"><a href="#addbe61eeebecd284aedecc7a9be9eaa1">&#9670;&nbsp;</a></span>create_logger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* srslog::create_logger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Creates a new logger instance with the specified id string, type and channel references, registering it into the logger repository so that it can be later retrieved in other parts of the application. Returns a pointer to the newly created logger, otherwise when a logger is already registered with the same id it returns nullptr. NOTE: T should be a type that is a logger. NOTE: Deprecated, use fetch_logger instead. </p>

</div>
</div>
<a id="a1993dfa16168200c10f5c7a663b76c23"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1993dfa16168200c10f5c7a663b76c23">&#9670;&nbsp;</a></span>create_stderr_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1sink.html">sink</a> * srslog::create_stderr_sink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;stderr&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new sink that writes into the stderr stream and registers it into a sink repository so that it can be later retrieved in other parts of the application. Different stderr sinks can be created by providing different names. Returns a pointer to the newly created sink or nullptr if a sink with the same name was already registered. NOTE: Deprecated, use get_stderr_sink instead. </p>

</div>
</div>
<a id="a03e25eac8a5194da24a61c1d822784a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a03e25eac8a5194da24a61c1d822784a8">&#9670;&nbsp;</a></span>create_stdout_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1sink.html">sink</a> * srslog::create_stdout_sink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em> = <code>&quot;stdout&quot;</code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Creates a new sink that writes into the stdout stream and registers it into a sink repository so that it can be later retrieved in other parts of the application. Different stdout sinks can be created by providing different names. Returns a pointer to the newly created sink or nullptr if a sink with the same name was already registered. NOTE: Deprecated, use get_stdout_sink instead. </p>

</div>
</div>
<a id="a40c6d308d4a5050c458b0a3b23ec0e2d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a40c6d308d4a5050c458b0a3b23ec0e2d">&#9670;&nbsp;</a></span>create_text_formatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt; srslog::create_text_formatter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Creates a new instance of a plain text formatter. </p>

</div>
</div>
<a id="a946c60f818b3d826b1f5a0f0ba376150"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a946c60f818b3d826b1f5a0f0ba376150">&#9670;&nbsp;</a></span>event_trace_init() <span class="overload">[1/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srslog::event_trace_init </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>The event tracing framework allows to trace any kind of event inside an application. To enable event tracing the ENABLE_SRSLOG_EVENT_TRACE macro symbol should be defined, otherwise calls to the tracing framework will be ignored. This is important to avoid the overhead of tracing when it is not required. For details about each event trace type please refer to: <a href="https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/edit">https://docs.google.com/document/d/1CvAClvFfyA5R-PhYUmn5OOQtYMH4h6I0nSsKchNAySU/edit</a> Initializes the event trace framework saving the trace events to a "event_trace.log" file. </p>

</div>
</div>
<a id="a67cfe514d89a22663b1e341f0587f6d8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a67cfe514d89a22663b1e341f0587f6d8">&#9670;&nbsp;</a></span>event_trace_init() <span class="overload">[2/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool srslog::event_trace_init </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>filename</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::size_t&#160;</td>
          <td class="paramname"><em>capacity</em> = <code>1024&#160;*&#160;1024</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the event trace framework. The event trace data will be written into the specified filename after capacity bytes of data have been generated or at program exit. Returns true on success, otherwise false. </p>

</div>
</div>
<a id="a0dd303fae83828d4ee378345cec28035"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0dd303fae83828d4ee378345cec28035">&#9670;&nbsp;</a></span>event_trace_init() <span class="overload">[3/3]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srslog::event_trace_init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> &amp;&#160;</td>
          <td class="paramname"><em>c</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Initializes the event trace framework using the specified log channel to log all trace events. </p>

</div>
</div>
<a id="a7c6cd017ea70905a8cb4486b7a7fdda6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7c6cd017ea70905a8cb4486b7a7fdda6">&#9670;&nbsp;</a></span>fetch_basic_logger() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesrslog.html#a89b5529471f90d5a87a25d5fb327f817">basic_logger</a> &amp; srslog::fetch_basic_logger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_print_context</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an instance of a basic logger (see basic_logger type) with the specified id string. All logger channels will write into the default sink. The context value of the logger can be printed on each log entry by setting to true the should_print_context argument. </p>

</div>
</div>
<a id="aca914c2ce2b461b62dfb2723df730913"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aca914c2ce2b461b62dfb2723df730913">&#9670;&nbsp;</a></span>fetch_basic_logger() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesrslog.html#a89b5529471f90d5a87a25d5fb327f817">basic_logger</a> &amp; srslog::fetch_basic_logger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>should_print_context</em> = <code>true</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an instance of a basic logger (see basic_logger type) with the specified id string. All logger channels will write into the specified sink. The context value of the logger can be printed on each log entry by setting to true the should_print_context argument. </p>

</div>
</div>
<a id="a32cd2feb425304352c404a0bb3820bd0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a32cd2feb425304352c404a0bb3820bd0">&#9670;&nbsp;</a></span>fetch_file_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp; srslog::fetch_file_sink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>path</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">size_t&#160;</td>
          <td class="paramname"><em>max_size</em> = <code>0</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>force_flush</em> = <code>false</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="namespacesrslog.html#ad5a7547e404f0bc584bd6a70da6cb657">get_default_log_formatter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an instance of a sink that writes into a file in the specified path. Specifying a max_size value different to zero will make the sink create a new file each time the current file exceeds this value. The units of max_size are bytes. Setting force_flush to true will flush the sink after every write. NOTE: Any '#' characters in the path will get removed. </p>

</div>
</div>
<a id="a72d4a47f68245076fdac9f070fc540c0"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a72d4a47f68245076fdac9f070fc540c0">&#9670;&nbsp;</a></span>fetch_log_channel() <span class="overload">[1/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> &amp; srslog::fetch_log_channel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an instance of a <a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> with the specified id that writes to the default sink using the default log channel configuration. NOTE: Any '#' characters in the id will get removed. </p>

</div>
</div>
<a id="a7ac88c2d34ede7e8394cb57051cd5460"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7ac88c2d34ede7e8394cb57051cd5460">&#9670;&nbsp;</a></span>fetch_log_channel() <span class="overload">[2/2]</span></h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> &amp; srslog::fetch_log_channel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="structsrslog_1_1log__channel__config.html">log_channel_config</a>&#160;</td>
          <td class="paramname"><em>config</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an instance of a <a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> with the specified id that writes to the specified sink. NOTE: Any '#' characters in the id will get removed. </p>

</div>
</div>
<a id="a22630d99c74c1fd5d1574212b5749851"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a22630d99c74c1fd5d1574212b5749851">&#9670;&nbsp;</a></span>fetch_logger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T , typename... Args&gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T&amp; srslog::fetch_logger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">Args &amp;&amp;...&#160;</td>
          <td class="paramname"><em>args</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Returns a logger instance with the specified id string, type and channel references. NOTE: T should be a type that is a logger. </p>

</div>
</div>
<a id="a621fabd5f188dfb4507fb7f95cbd4c95"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a621fabd5f188dfb4507fb7f95cbd4c95">&#9670;&nbsp;</a></span>fetch_stderr_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp; srslog::fetch_stderr_sink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em> = <code>&quot;stderr&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="namespacesrslog.html#ad5a7547e404f0bc584bd6a70da6cb657">get_default_log_formatter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an instance of a sink that writes to the stderr stream. You may use different ids if you need to create multiple stderr sinks with different formatters. </p>

</div>
</div>
<a id="a7bb4851a82eba1da59777a916b577435"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7bb4851a82eba1da59777a916b577435">&#9670;&nbsp;</a></span>fetch_stdout_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp; srslog::fetch_stdout_sink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em> = <code>&quot;stdout&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="namespacesrslog.html#ad5a7547e404f0bc584bd6a70da6cb657">get_default_log_formatter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an instance of a sink that writes to the stdout stream. You may use different ids if you need to create multiple stdout sinks with different formatters. </p>

</div>
</div>
<a id="a7eb515b75d44f0e4605e51f3f9e489e9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a7eb515b75d44f0e4605e51f3f9e489e9">&#9670;&nbsp;</a></span>fetch_syslog_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp; srslog::fetch_syslog_sink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>preamble_</em> = <code>&quot;&quot;</code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2">syslog_local_type</a>&#160;</td>
          <td class="paramname"><em>log_local_</em> = <code><a class="el" href="namespacesrslog.html#ac63a825d4f47c99e518bee30c3567bb2a5383337459a9ea598578681bcb0480db">syslog_local_type::local0</a></code>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em> = <code><a class="el" href="namespacesrslog.html#ad5a7547e404f0bc584bd6a70da6cb657">get_default_log_formatter</a>()</code>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Returns an instance of a sink that writes into syslog preamble: The string prepended to every message, If ident is "", the program name is used. log_local: custom unused facilities that syslog provides which can be used by the user NOTE: Any '#' characters in the path will get removed. </p>

</div>
</div>
<a id="a92ad8357c6a61d0342715fdedd2b17d2"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a92ad8357c6a61d0342715fdedd2b17d2">&#9670;&nbsp;</a></span>find_log_channel()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1log__channel.html">log_channel</a> * srslog::find_log_channel </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>NOTE: All functions are thread safe unless otherwise specified. Log channel management functions. Finds a log channel with the specified id string in the repository. On success returns a pointer to the requested log channel, otherwise nullptr.</p>
<p>Log channel management function implementations. </p>

</div>
</div>
<a id="a09c20c3b17519c97a8d2ba157b1d3540"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a09c20c3b17519c97a8d2ba157b1d3540">&#9670;&nbsp;</a></span>find_logger()</h2>

<div class="memitem">
<div class="memproto">
<div class="memtemplate">
template&lt;typename T &gt; </div>
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname">T* srslog::find_logger </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">
<p>Finds a logger with the specified id string and type in the repository. On success returns a pointer to the requested logger, otherwise nullptr. NOTE: T should be a type that is a logger. </p>

</div>
</div>
<a id="a749ff4d70c896d2116b8e37dbcc5f1a4"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a749ff4d70c896d2116b8e37dbcc5f1a4">&#9670;&nbsp;</a></span>find_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1sink.html">sink</a> * srslog::find_sink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Finds a sink with the specified id string in the repository. On success returns a pointer to the requested sink, otherwise nullptr. </p>

</div>
</div>
<a id="a87b0feff706ec57dfdeb274d43d72863"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a87b0feff706ec57dfdeb274d43d72863">&#9670;&nbsp;</a></span>flush()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srslog::flush </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Flushes the contents of all the registered sinks. The caller thread will block until the operation is completed. NOTE: This function does nothing if <a class="el" href="namespacesrslog.html#a6a7c7c3e1d4bdf3c1ebe9a69378c6a6a">init()</a> has not been called. </p>

</div>
</div>
<a id="ad5a7547e404f0bc584bd6a70da6cb657"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad5a7547e404f0bc584bd6a70da6cb657">&#9670;&nbsp;</a></span>get_default_log_formatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt; srslog::get_default_log_formatter </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the instance of the default formatter being used. </p>

</div>
</div>
<a id="a0623fc7d81853101ea2ba91af52cacd6"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0623fc7d81853101ea2ba91af52cacd6">&#9670;&nbsp;</a></span>get_default_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp; srslog::get_default_sink </td>
          <td>(</td>
          <td class="paramname"></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Returns the instance of the default sink being used. </p>

</div>
</div>
<a id="a6a7c7c3e1d4bdf3c1ebe9a69378c6a6a"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6a7c7c3e1d4bdf3c1ebe9a69378c6a6a">&#9670;&nbsp;</a></span>init()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srslog::init </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesrslog.html#abaa7a7501dbd413398b3d6f951f58773">backend_priority</a>&#160;</td>
          <td class="paramname"><em>priority</em> = <code><a class="el" href="namespacesrslog.html#abaa7a7501dbd413398b3d6f951f58773afea087517c26fadd409bd4b9dc642555">backend_priority::normal</a></code></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Framework configuration and control functions. This function initializes the logging framework. It must be called before any log entry is generated. NOTE: Calling this function more than once has no side effects.</p>
<p>Framework configuration and control function implementations. </p>

</div>
</div>
<a id="a052d09ff6ba29cfbb6c7fa4ab55fba98"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a052d09ff6ba29cfbb6c7fa4ab55fba98">&#9670;&nbsp;</a></span>install_custom_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">bool srslog::install_custom_sink </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>id</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1sink.html">sink</a> &gt;&#160;</td>
          <td class="paramname"><em>s</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Installs a custom user defined sink in the framework getting associated to the specified id. Returns true on success, otherwise false. WARNING: This function is an advanced feature and users should really know what they are doing when using it. </p>

</div>
</div>
<a id="aefdd9a58c2b2885ec468ae3abd80cfa7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aefdd9a58c2b2885ec468ae3abd80cfa7">&#9670;&nbsp;</a></span>set_default_log_formatter()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srslog::set_default_log_formatter </td>
          <td>(</td>
          <td class="paramtype">std::unique_ptr&lt; <a class="el" href="classsrslog_1_1log__formatter.html">log_formatter</a> &gt;&#160;</td>
          <td class="paramname"><em>f</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Formatter management functions. Installs the specified formatter to be used as the default one by new sinks. The initial default formatter formats plain text.</p>
<p>Formatter management functions. </p>

</div>
</div>
<a id="a1d3a09079d5f4719cfa542e7bb17efed"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a1d3a09079d5f4719cfa542e7bb17efed">&#9670;&nbsp;</a></span>set_default_sink()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srslog::set_default_sink </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="classsrslog_1_1sink.html">sink</a> &amp;&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Sink management functions. Installs the specified sink to be used as the default one by new log channels and loggers. The initial default sink writes to stdout with a text formatter.</p>
<p>Sink management function implementations. </p>

</div>
</div>
<a id="af10e6d28e5102d0a6a8156a6ac39c823"></a>
<h2 class="memtitle"><span class="permalink"><a href="#af10e6d28e5102d0a6a8156a6ac39c823">&#9670;&nbsp;</a></span>set_error_handler()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srslog::set_error_handler </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="namespacesrslog.html#aeef1a25fb1b5027288884a431890e33e">error_handler</a>&#160;</td>
          <td class="paramname"><em>handler</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">
<p>Installs the specified error handler to receive any error messages generated by the framework. NOTE: This function should be called before <a class="el" href="namespacesrslog.html#a6a7c7c3e1d4bdf3c1ebe9a69378c6a6a">init()</a> and is NOT thread safe. </p>

</div>
</div>
<a id="a0921e1312e0de12d19f1cc898958d9dd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a0921e1312e0de12d19f1cc898958d9dd">&#9670;&nbsp;</a></span>str_to_basic_level()</h2>

<div class="memitem">
<div class="memproto">
<table class="mlabels">
  <tr>
  <td class="mlabels-left">
      <table class="memname">
        <tr>
          <td class="memname"><a class="el" href="namespacesrslog.html#a2f24235d23f40dcc7be241dd20d53e84">basic_levels</a> srslog::str_to_basic_level </td>
          <td>(</td>
          <td class="paramtype">std::string&#160;</td>
          <td class="paramname"><em>s</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
  </td>
  <td class="mlabels-right">
<span class="mlabels"><span class="mlabel">inline</span></span>  </td>
  </tr>
</table>
</div><div class="memdoc">

<p>Translates a string to the corresponding logger basic level. </p>

</div>
</div>
<a id="a2806d7ab3f3c1eaf24ad0706d376df35"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2806d7ab3f3c1eaf24ad0706d376df35">&#9670;&nbsp;</a></span>trace_duration_begin()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srslog::trace_duration_begin </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
<a id="aac8f98c047129b542615897470087126"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aac8f98c047129b542615897470087126">&#9670;&nbsp;</a></span>trace_duration_end()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void srslog::trace_duration_end </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>category</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>name</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by &#160;<a href="http://www.doxygen.org/index.html">
<img class="footer" src="doxygen.png" alt="doxygen"/>
</a> 1.8.17
</small></address>
</body>
</html>
